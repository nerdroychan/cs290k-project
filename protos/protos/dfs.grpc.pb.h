// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: protos/dfs.proto
#ifndef GRPC_protos_2fdfs_2eproto__INCLUDED
#define GRPC_protos_2fdfs_2eproto__INCLUDED

#include "protos/dfs.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace dfs {

class DFS final {
 public:
  static constexpr char const* service_full_name() {
    return "dfs.DFS";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // $getdir
    virtual ::grpc::Status get_dir(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Str* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Str>> Asyncget_dir(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Str>>(Asyncget_dirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Str>> PrepareAsyncget_dir(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Str>>(PrepareAsyncget_dirRaw(context, request, cq));
    }
    // $cd directory_name
    virtual ::grpc::Status change_dir(::grpc::ClientContext* context, const ::dfs::Str& request, ::dfs::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> Asyncchange_dir(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(Asyncchange_dirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> PrepareAsyncchange_dir(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(PrepareAsyncchange_dirRaw(context, request, cq));
    }
    // $filecount
    virtual ::grpc::Status file_count(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Int* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Int>> Asyncfile_count(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Int>>(Asyncfile_countRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Int>> PrepareAsyncfile_count(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Int>>(PrepareAsyncfile_countRaw(context, request, cq));
    }
    // $ls [-l] [directory_name]
    virtual ::grpc::Status open_list(::grpc::ClientContext* context, const ::dfs::Str& request, ::dfs::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> Asyncopen_list(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(Asyncopen_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> PrepareAsyncopen_list(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(PrepareAsyncopen_listRaw(context, request, cq));
    }
    virtual ::grpc::Status next_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Dentry* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Dentry>> Asyncnext_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Dentry>>(Asyncnext_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Dentry>> PrepareAsyncnext_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Dentry>>(PrepareAsyncnext_listRaw(context, request, cq));
    }
    virtual ::grpc::Status close_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> Asyncclose_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(Asyncclose_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> PrepareAsyncclose_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(PrepareAsyncclose_listRaw(context, request, cq));
    }
    // $put localfile [remotefile]
    virtual ::grpc::Status open_file_to_write(::grpc::ClientContext* context, const ::dfs::Str& request, ::dfs::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> Asyncopen_file_to_write(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(Asyncopen_file_to_writeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> PrepareAsyncopen_file_to_write(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(PrepareAsyncopen_file_to_writeRaw(context, request, cq));
    }
    virtual ::grpc::Status next_write(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::dfs::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> Asyncnext_write(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(Asyncnext_writeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> PrepareAsyncnext_write(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(PrepareAsyncnext_writeRaw(context, request, cq));
    }
    // $get remotefile [localfile]
    virtual ::grpc::Status open_file_to_read(::grpc::ClientContext* context, const ::dfs::Str& request, ::dfs::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> Asyncopen_file_to_read(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(Asyncopen_file_to_readRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> PrepareAsyncopen_file_to_read(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(PrepareAsyncopen_file_to_readRaw(context, request, cq));
    }
    virtual ::grpc::Status next_read(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::ReadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>> Asyncnext_read(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>>(Asyncnext_readRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>> PrepareAsyncnext_read(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>>(PrepareAsyncnext_readRaw(context, request, cq));
    }
    // $randomread remotefile firstbyte numbytes
    virtual ::grpc::Status random_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::dfs::ReadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>> Asyncrandom_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>>(Asyncrandom_readRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>> PrepareAsyncrandom_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>>(PrepareAsyncrandom_readRaw(context, request, cq));
    }
    virtual ::grpc::Status close_file(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> Asyncclose_file(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(Asyncclose_fileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>> PrepareAsyncclose_file(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>>(PrepareAsyncclose_fileRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // $getdir
      virtual void get_dir(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Str* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_dir(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Str* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_dir(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_dir(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // $cd directory_name
      virtual void change_dir(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void change_dir(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void change_dir(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void change_dir(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // $filecount
      virtual void file_count(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Int* response, std::function<void(::grpc::Status)>) = 0;
      virtual void file_count(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Int* response, std::function<void(::grpc::Status)>) = 0;
      virtual void file_count(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Int* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void file_count(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Int* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // $ls [-l] [directory_name]
      virtual void open_list(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void open_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void open_list(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void open_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void next_list(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Dentry* response, std::function<void(::grpc::Status)>) = 0;
      virtual void next_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Dentry* response, std::function<void(::grpc::Status)>) = 0;
      virtual void next_list(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Dentry* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void next_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Dentry* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void close_list(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void close_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void close_list(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void close_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // $put localfile [remotefile]
      virtual void open_file_to_write(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void open_file_to_write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void open_file_to_write(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void open_file_to_write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void next_write(::grpc::ClientContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void next_write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void next_write(::grpc::ClientContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void next_write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // $get remotefile [localfile]
      virtual void open_file_to_read(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void open_file_to_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void open_file_to_read(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void open_file_to_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void next_read(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void next_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::ReadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void next_read(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void next_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // $randomread remotefile firstbyte numbytes
      virtual void random_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void random_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::ReadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void random_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void random_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void close_file(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void close_file(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void close_file(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void close_file(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Str>* Asyncget_dirRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Str>* PrepareAsyncget_dirRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* Asyncchange_dirRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* PrepareAsyncchange_dirRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Int>* Asyncfile_countRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Int>* PrepareAsyncfile_countRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* Asyncopen_listRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* PrepareAsyncopen_listRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Dentry>* Asyncnext_listRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Dentry>* PrepareAsyncnext_listRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* Asyncclose_listRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* PrepareAsyncclose_listRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* Asyncopen_file_to_writeRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* PrepareAsyncopen_file_to_writeRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* Asyncnext_writeRaw(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* PrepareAsyncnext_writeRaw(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* Asyncopen_file_to_readRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* PrepareAsyncopen_file_to_readRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>* Asyncnext_readRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>* PrepareAsyncnext_readRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>* Asyncrandom_readRaw(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReadResponse>* PrepareAsyncrandom_readRaw(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* Asyncclose_fileRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::Bool>* PrepareAsyncclose_fileRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status get_dir(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Str* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Str>> Asyncget_dir(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Str>>(Asyncget_dirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Str>> PrepareAsyncget_dir(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Str>>(PrepareAsyncget_dirRaw(context, request, cq));
    }
    ::grpc::Status change_dir(::grpc::ClientContext* context, const ::dfs::Str& request, ::dfs::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> Asyncchange_dir(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(Asyncchange_dirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> PrepareAsyncchange_dir(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(PrepareAsyncchange_dirRaw(context, request, cq));
    }
    ::grpc::Status file_count(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Int* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Int>> Asyncfile_count(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Int>>(Asyncfile_countRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Int>> PrepareAsyncfile_count(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Int>>(PrepareAsyncfile_countRaw(context, request, cq));
    }
    ::grpc::Status open_list(::grpc::ClientContext* context, const ::dfs::Str& request, ::dfs::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> Asyncopen_list(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(Asyncopen_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> PrepareAsyncopen_list(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(PrepareAsyncopen_listRaw(context, request, cq));
    }
    ::grpc::Status next_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Dentry* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Dentry>> Asyncnext_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Dentry>>(Asyncnext_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Dentry>> PrepareAsyncnext_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Dentry>>(PrepareAsyncnext_listRaw(context, request, cq));
    }
    ::grpc::Status close_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> Asyncclose_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(Asyncclose_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> PrepareAsyncclose_list(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(PrepareAsyncclose_listRaw(context, request, cq));
    }
    ::grpc::Status open_file_to_write(::grpc::ClientContext* context, const ::dfs::Str& request, ::dfs::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> Asyncopen_file_to_write(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(Asyncopen_file_to_writeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> PrepareAsyncopen_file_to_write(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(PrepareAsyncopen_file_to_writeRaw(context, request, cq));
    }
    ::grpc::Status next_write(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::dfs::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> Asyncnext_write(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(Asyncnext_writeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> PrepareAsyncnext_write(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(PrepareAsyncnext_writeRaw(context, request, cq));
    }
    ::grpc::Status open_file_to_read(::grpc::ClientContext* context, const ::dfs::Str& request, ::dfs::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> Asyncopen_file_to_read(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(Asyncopen_file_to_readRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> PrepareAsyncopen_file_to_read(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(PrepareAsyncopen_file_to_readRaw(context, request, cq));
    }
    ::grpc::Status next_read(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::ReadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>> Asyncnext_read(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>>(Asyncnext_readRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>> PrepareAsyncnext_read(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>>(PrepareAsyncnext_readRaw(context, request, cq));
    }
    ::grpc::Status random_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::dfs::ReadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>> Asyncrandom_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>>(Asyncrandom_readRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>> PrepareAsyncrandom_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>>(PrepareAsyncrandom_readRaw(context, request, cq));
    }
    ::grpc::Status close_file(::grpc::ClientContext* context, const ::dfs::Void& request, ::dfs::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> Asyncclose_file(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(Asyncclose_fileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>> PrepareAsyncclose_file(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::Bool>>(PrepareAsyncclose_fileRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void get_dir(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Str* response, std::function<void(::grpc::Status)>) override;
      void get_dir(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Str* response, std::function<void(::grpc::Status)>) override;
      void get_dir(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_dir(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void change_dir(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void change_dir(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void change_dir(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void change_dir(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void file_count(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Int* response, std::function<void(::grpc::Status)>) override;
      void file_count(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Int* response, std::function<void(::grpc::Status)>) override;
      void file_count(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Int* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void file_count(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Int* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void open_list(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void open_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void open_list(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void open_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void next_list(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Dentry* response, std::function<void(::grpc::Status)>) override;
      void next_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Dentry* response, std::function<void(::grpc::Status)>) override;
      void next_list(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Dentry* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void next_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Dentry* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void close_list(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void close_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void close_list(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void close_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void open_file_to_write(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void open_file_to_write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void open_file_to_write(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void open_file_to_write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void next_write(::grpc::ClientContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void next_write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void next_write(::grpc::ClientContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void next_write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void open_file_to_read(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void open_file_to_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void open_file_to_read(::grpc::ClientContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void open_file_to_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void next_read(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response, std::function<void(::grpc::Status)>) override;
      void next_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::ReadResponse* response, std::function<void(::grpc::Status)>) override;
      void next_read(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void next_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void random_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response, std::function<void(::grpc::Status)>) override;
      void random_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::ReadResponse* response, std::function<void(::grpc::Status)>) override;
      void random_read(::grpc::ClientContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void random_read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void close_file(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void close_file(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, std::function<void(::grpc::Status)>) override;
      void close_file(::grpc::ClientContext* context, const ::dfs::Void* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void close_file(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dfs::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::dfs::Str>* Asyncget_dirRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Str>* PrepareAsyncget_dirRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* Asyncchange_dirRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* PrepareAsyncchange_dirRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Int>* Asyncfile_countRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Int>* PrepareAsyncfile_countRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* Asyncopen_listRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* PrepareAsyncopen_listRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Dentry>* Asyncnext_listRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Dentry>* PrepareAsyncnext_listRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* Asyncclose_listRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* PrepareAsyncclose_listRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* Asyncopen_file_to_writeRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* PrepareAsyncopen_file_to_writeRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* Asyncnext_writeRaw(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* PrepareAsyncnext_writeRaw(::grpc::ClientContext* context, const ::dfs::WriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* Asyncopen_file_to_readRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* PrepareAsyncopen_file_to_readRaw(::grpc::ClientContext* context, const ::dfs::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>* Asyncnext_readRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>* PrepareAsyncnext_readRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>* Asyncrandom_readRaw(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::ReadResponse>* PrepareAsyncrandom_readRaw(::grpc::ClientContext* context, const ::dfs::RandomReadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* Asyncclose_fileRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::Bool>* PrepareAsyncclose_fileRaw(::grpc::ClientContext* context, const ::dfs::Void& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_get_dir_;
    const ::grpc::internal::RpcMethod rpcmethod_change_dir_;
    const ::grpc::internal::RpcMethod rpcmethod_file_count_;
    const ::grpc::internal::RpcMethod rpcmethod_open_list_;
    const ::grpc::internal::RpcMethod rpcmethod_next_list_;
    const ::grpc::internal::RpcMethod rpcmethod_close_list_;
    const ::grpc::internal::RpcMethod rpcmethod_open_file_to_write_;
    const ::grpc::internal::RpcMethod rpcmethod_next_write_;
    const ::grpc::internal::RpcMethod rpcmethod_open_file_to_read_;
    const ::grpc::internal::RpcMethod rpcmethod_next_read_;
    const ::grpc::internal::RpcMethod rpcmethod_random_read_;
    const ::grpc::internal::RpcMethod rpcmethod_close_file_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // $getdir
    virtual ::grpc::Status get_dir(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Str* response);
    // $cd directory_name
    virtual ::grpc::Status change_dir(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response);
    // $filecount
    virtual ::grpc::Status file_count(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Int* response);
    // $ls [-l] [directory_name]
    virtual ::grpc::Status open_list(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response);
    virtual ::grpc::Status next_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Dentry* response);
    virtual ::grpc::Status close_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response);
    // $put localfile [remotefile]
    virtual ::grpc::Status open_file_to_write(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response);
    virtual ::grpc::Status next_write(::grpc::ServerContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response);
    // $get remotefile [localfile]
    virtual ::grpc::Status open_file_to_read(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response);
    virtual ::grpc::Status next_read(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response);
    // $randomread remotefile firstbyte numbytes
    virtual ::grpc::Status random_read(::grpc::ServerContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response);
    virtual ::grpc::Status close_file(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_get_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_get_dir() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_get_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dir(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_dir(::grpc::ServerContext* context, ::dfs::Void* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Str>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_change_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_change_dir() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_change_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status change_dir(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestchange_dir(::grpc::ServerContext* context, ::dfs::Str* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_file_count : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_file_count() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_file_count() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status file_count(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Int* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestfile_count(::grpc::ServerContext* context, ::dfs::Void* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Int>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_open_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_open_list() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_open_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_list(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestopen_list(::grpc::ServerContext* context, ::dfs::Str* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_next_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_next_list() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_next_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Dentry* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnext_list(::grpc::ServerContext* context, ::dfs::Void* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Dentry>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_close_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_close_list() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_close_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclose_list(::grpc::ServerContext* context, ::dfs::Void* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_open_file_to_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_open_file_to_write() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_open_file_to_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_write(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestopen_file_to_write(::grpc::ServerContext* context, ::dfs::Str* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_next_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_next_write() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_next_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_write(::grpc::ServerContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnext_write(::grpc::ServerContext* context, ::dfs::WriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_open_file_to_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_open_file_to_read() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_open_file_to_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_read(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestopen_file_to_read(::grpc::ServerContext* context, ::dfs::Str* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_next_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_next_read() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_next_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_read(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnext_read(::grpc::ServerContext* context, ::dfs::Void* request, ::grpc::ServerAsyncResponseWriter< ::dfs::ReadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_random_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_random_read() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_random_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status random_read(::grpc::ServerContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrandom_read(::grpc::ServerContext* context, ::dfs::RandomReadRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::ReadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_close_file : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_close_file() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_close_file() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_file(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclose_file(::grpc::ServerContext* context, ::dfs::Void* request, ::grpc::ServerAsyncResponseWriter< ::dfs::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_get_dir<WithAsyncMethod_change_dir<WithAsyncMethod_file_count<WithAsyncMethod_open_list<WithAsyncMethod_next_list<WithAsyncMethod_close_list<WithAsyncMethod_open_file_to_write<WithAsyncMethod_next_write<WithAsyncMethod_open_file_to_read<WithAsyncMethod_next_read<WithAsyncMethod_random_read<WithAsyncMethod_close_file<Service > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_get_dir() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Str>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Void* request,
                 ::dfs::Str* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->get_dir(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_get_dir(
        ::grpc::experimental::MessageAllocator< ::dfs::Void, ::dfs::Str>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Str>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dir(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_dir(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Str* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_change_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_change_dir() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Str, ::dfs::Bool>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Str* request,
                 ::dfs::Bool* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->change_dir(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_change_dir(
        ::grpc::experimental::MessageAllocator< ::dfs::Str, ::dfs::Bool>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Str, ::dfs::Bool>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_change_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status change_dir(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void change_dir(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_file_count : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_file_count() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Int>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Void* request,
                 ::dfs::Int* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->file_count(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_file_count(
        ::grpc::experimental::MessageAllocator< ::dfs::Void, ::dfs::Int>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Int>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_file_count() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status file_count(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Int* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void file_count(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Int* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_open_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_open_list() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Str, ::dfs::Bool>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Str* request,
                 ::dfs::Bool* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->open_list(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_open_list(
        ::grpc::experimental::MessageAllocator< ::dfs::Str, ::dfs::Bool>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Str, ::dfs::Bool>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_open_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_list(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void open_list(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_next_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_next_list() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Dentry>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Void* request,
                 ::dfs::Dentry* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->next_list(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_next_list(
        ::grpc::experimental::MessageAllocator< ::dfs::Void, ::dfs::Dentry>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Dentry>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_next_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Dentry* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void next_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Dentry* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_close_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_close_list() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Bool>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Void* request,
                 ::dfs::Bool* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->close_list(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_close_list(
        ::grpc::experimental::MessageAllocator< ::dfs::Void, ::dfs::Bool>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Bool>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_close_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void close_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_open_file_to_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_open_file_to_write() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Str, ::dfs::Bool>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Str* request,
                 ::dfs::Bool* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->open_file_to_write(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_open_file_to_write(
        ::grpc::experimental::MessageAllocator< ::dfs::Str, ::dfs::Bool>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Str, ::dfs::Bool>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_open_file_to_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_write(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void open_file_to_write(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_next_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_next_write() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::WriteRequest, ::dfs::Bool>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::WriteRequest* request,
                 ::dfs::Bool* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->next_write(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_next_write(
        ::grpc::experimental::MessageAllocator< ::dfs::WriteRequest, ::dfs::Bool>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::WriteRequest, ::dfs::Bool>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_next_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_write(::grpc::ServerContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void next_write(::grpc::ServerContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_open_file_to_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_open_file_to_read() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Str, ::dfs::Bool>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Str* request,
                 ::dfs::Bool* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->open_file_to_read(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_open_file_to_read(
        ::grpc::experimental::MessageAllocator< ::dfs::Str, ::dfs::Bool>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Str, ::dfs::Bool>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_open_file_to_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_read(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void open_file_to_read(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_next_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_next_read() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::ReadResponse>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Void* request,
                 ::dfs::ReadResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->next_read(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_next_read(
        ::grpc::experimental::MessageAllocator< ::dfs::Void, ::dfs::ReadResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::ReadResponse>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_next_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_read(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void next_read(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_random_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_random_read() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::RandomReadRequest, ::dfs::ReadResponse>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::RandomReadRequest* request,
                 ::dfs::ReadResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->random_read(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_random_read(
        ::grpc::experimental::MessageAllocator< ::dfs::RandomReadRequest, ::dfs::ReadResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::RandomReadRequest, ::dfs::ReadResponse>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_random_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status random_read(::grpc::ServerContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void random_read(::grpc::ServerContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_close_file : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_close_file() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Bool>(
          [this](::grpc::ServerContext* context,
                 const ::dfs::Void* request,
                 ::dfs::Bool* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->close_file(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_close_file(
        ::grpc::experimental::MessageAllocator< ::dfs::Void, ::dfs::Bool>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::Void, ::dfs::Bool>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_close_file() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_file(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void close_file(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_get_dir<ExperimentalWithCallbackMethod_change_dir<ExperimentalWithCallbackMethod_file_count<ExperimentalWithCallbackMethod_open_list<ExperimentalWithCallbackMethod_next_list<ExperimentalWithCallbackMethod_close_list<ExperimentalWithCallbackMethod_open_file_to_write<ExperimentalWithCallbackMethod_next_write<ExperimentalWithCallbackMethod_open_file_to_read<ExperimentalWithCallbackMethod_next_read<ExperimentalWithCallbackMethod_random_read<ExperimentalWithCallbackMethod_close_file<Service > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_get_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_get_dir() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_get_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dir(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_change_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_change_dir() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_change_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status change_dir(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_file_count : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_file_count() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_file_count() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status file_count(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Int* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_open_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_open_list() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_open_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_list(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_next_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_next_list() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_next_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Dentry* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_close_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_close_list() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_close_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_open_file_to_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_open_file_to_write() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_open_file_to_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_write(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_next_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_next_write() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_next_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_write(::grpc::ServerContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_open_file_to_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_open_file_to_read() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_open_file_to_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_read(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_next_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_next_read() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_next_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_read(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_random_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_random_read() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_random_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status random_read(::grpc::ServerContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_close_file : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_close_file() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_close_file() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_file(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_get_dir() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_get_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dir(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_dir(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_change_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_change_dir() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_change_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status change_dir(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestchange_dir(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_file_count : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_file_count() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_file_count() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status file_count(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Int* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestfile_count(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_open_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_open_list() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_open_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_list(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestopen_list(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_next_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_next_list() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_next_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Dentry* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnext_list(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_close_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_close_list() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_close_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclose_list(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_open_file_to_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_open_file_to_write() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_open_file_to_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_write(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestopen_file_to_write(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_next_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_next_write() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_next_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_write(::grpc::ServerContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnext_write(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_open_file_to_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_open_file_to_read() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_open_file_to_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_read(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestopen_file_to_read(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_next_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_next_read() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_next_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_read(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnext_read(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_random_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_random_read() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_random_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status random_read(::grpc::ServerContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrandom_read(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_close_file : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_close_file() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_close_file() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_file(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclose_file(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_get_dir() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->get_dir(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_get_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dir(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_dir(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_change_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_change_dir() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->change_dir(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_change_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status change_dir(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void change_dir(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_file_count : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_file_count() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->file_count(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_file_count() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status file_count(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Int* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void file_count(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_open_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_open_list() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->open_list(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_open_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_list(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void open_list(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_next_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_next_list() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->next_list(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_next_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Dentry* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void next_list(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_close_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_close_list() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->close_list(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_close_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void close_list(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_open_file_to_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_open_file_to_write() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->open_file_to_write(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_open_file_to_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_write(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void open_file_to_write(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_next_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_next_write() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->next_write(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_next_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_write(::grpc::ServerContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void next_write(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_open_file_to_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_open_file_to_read() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->open_file_to_read(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_open_file_to_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status open_file_to_read(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void open_file_to_read(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_next_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_next_read() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->next_read(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_next_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status next_read(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void next_read(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_random_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_random_read() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->random_read(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_random_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status random_read(::grpc::ServerContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void random_read(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_close_file : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_close_file() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->close_file(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_close_file() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close_file(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void close_file(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_get_dir() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Void, ::dfs::Str>(std::bind(&WithStreamedUnaryMethod_get_dir<BaseClass>::Streamedget_dir, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_get_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_dir(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_dir(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Void,::dfs::Str>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_change_dir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_change_dir() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Str, ::dfs::Bool>(std::bind(&WithStreamedUnaryMethod_change_dir<BaseClass>::Streamedchange_dir, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_change_dir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status change_dir(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedchange_dir(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Str,::dfs::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_file_count : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_file_count() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Void, ::dfs::Int>(std::bind(&WithStreamedUnaryMethod_file_count<BaseClass>::Streamedfile_count, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_file_count() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status file_count(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Int* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedfile_count(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Void,::dfs::Int>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_open_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_open_list() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Str, ::dfs::Bool>(std::bind(&WithStreamedUnaryMethod_open_list<BaseClass>::Streamedopen_list, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_open_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status open_list(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedopen_list(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Str,::dfs::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_next_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_next_list() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Void, ::dfs::Dentry>(std::bind(&WithStreamedUnaryMethod_next_list<BaseClass>::Streamednext_list, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_next_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status next_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Dentry* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamednext_list(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Void,::dfs::Dentry>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_close_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_close_list() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Void, ::dfs::Bool>(std::bind(&WithStreamedUnaryMethod_close_list<BaseClass>::Streamedclose_list, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_close_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status close_list(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclose_list(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Void,::dfs::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_open_file_to_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_open_file_to_write() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Str, ::dfs::Bool>(std::bind(&WithStreamedUnaryMethod_open_file_to_write<BaseClass>::Streamedopen_file_to_write, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_open_file_to_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status open_file_to_write(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedopen_file_to_write(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Str,::dfs::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_next_write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_next_write() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::WriteRequest, ::dfs::Bool>(std::bind(&WithStreamedUnaryMethod_next_write<BaseClass>::Streamednext_write, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_next_write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status next_write(::grpc::ServerContext* context, const ::dfs::WriteRequest* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamednext_write(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::WriteRequest,::dfs::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_open_file_to_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_open_file_to_read() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Str, ::dfs::Bool>(std::bind(&WithStreamedUnaryMethod_open_file_to_read<BaseClass>::Streamedopen_file_to_read, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_open_file_to_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status open_file_to_read(::grpc::ServerContext* context, const ::dfs::Str* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedopen_file_to_read(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Str,::dfs::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_next_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_next_read() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Void, ::dfs::ReadResponse>(std::bind(&WithStreamedUnaryMethod_next_read<BaseClass>::Streamednext_read, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_next_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status next_read(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamednext_read(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Void,::dfs::ReadResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_random_read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_random_read() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::RandomReadRequest, ::dfs::ReadResponse>(std::bind(&WithStreamedUnaryMethod_random_read<BaseClass>::Streamedrandom_read, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_random_read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status random_read(::grpc::ServerContext* context, const ::dfs::RandomReadRequest* request, ::dfs::ReadResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedrandom_read(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::RandomReadRequest,::dfs::ReadResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_close_file : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_close_file() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::dfs::Void, ::dfs::Bool>(std::bind(&WithStreamedUnaryMethod_close_file<BaseClass>::Streamedclose_file, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_close_file() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status close_file(::grpc::ServerContext* context, const ::dfs::Void* request, ::dfs::Bool* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclose_file(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::Void,::dfs::Bool>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_get_dir<WithStreamedUnaryMethod_change_dir<WithStreamedUnaryMethod_file_count<WithStreamedUnaryMethod_open_list<WithStreamedUnaryMethod_next_list<WithStreamedUnaryMethod_close_list<WithStreamedUnaryMethod_open_file_to_write<WithStreamedUnaryMethod_next_write<WithStreamedUnaryMethod_open_file_to_read<WithStreamedUnaryMethod_next_read<WithStreamedUnaryMethod_random_read<WithStreamedUnaryMethod_close_file<Service > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_get_dir<WithStreamedUnaryMethod_change_dir<WithStreamedUnaryMethod_file_count<WithStreamedUnaryMethod_open_list<WithStreamedUnaryMethod_next_list<WithStreamedUnaryMethod_close_list<WithStreamedUnaryMethod_open_file_to_write<WithStreamedUnaryMethod_next_write<WithStreamedUnaryMethod_open_file_to_read<WithStreamedUnaryMethod_next_read<WithStreamedUnaryMethod_random_read<WithStreamedUnaryMethod_close_file<Service > > > > > > > > > > > > StreamedService;
};

}  // namespace dfs


#endif  // GRPC_protos_2fdfs_2eproto__INCLUDED
